
export type Question = {
  id: number;
  text: string;
  type: 'mcq' | 'code';
  codeSnippet?: string;
  options?: string[];
  correctAnswer: string;
  explanation: string;
};

export type Quiz = {
  id: string;
  title: string;
  description: string;
  difficulty: 'Easy' | 'Medium' | 'Hard';
  questions: Question[];
};

export const quizzes: Quiz[] = [
  {
    id: 'c-basics-1',
    title: 'C Language Basics',
    description: 'Test your knowledge of fundamental C concepts.',
    difficulty: 'Easy',
    questions: [
      {
        id: 1,
        text: 'Which of the following is a keyword in C?',
        type: 'mcq',
        options: ['integer', 'float', 'return', 'function'],
        correctAnswer: 'return',
        explanation: "'return' is a keyword in C used to terminate a function and return a value. The others are data types or concepts, but not keywords themselves.",
      },
      {
        id: 2,
        text: 'What is the correct way to declare an integer variable named "score"?',
        type: 'mcq',
        options: ['int score;', 'integer score;', 'score int;', 'declare score as int;'],
        correctAnswer: 'int score;',
        explanation: 'In C, variables are declared with the syntax: `data_type variable_name;`. So, `int score;` is the correct way.',
      },
      {
        id: 3,
        text: 'What is the purpose of the #include <stdio.h> directive?',
        type: 'mcq',
        options: ['To define a new standard library', 'To include the source code of the stdio.h file in the current file', 'To link the standard input/output library', 'To declare standard input/output functions'],
        correctAnswer: 'To include the source code of the stdio.h file in the current file',
        explanation: 'The #include directive tells the preprocessor to include the contents of the specified file at that point in the code. For <stdio.h>, this makes standard I/O functions like printf and scanf available.',
      },
      {
        id: 4,
        text: 'Which format specifier is used to print a floating-point number?',
        type: 'mcq',
        options: ['%d', '%c', '%s', '%f'],
        correctAnswer: '%f',
        explanation: '%f is used for floats and doubles, %d for integers, %c for characters, and %s for strings.',
      },
      {
        id: 5,
        text: 'What is the result of 7 % 3 in C?',
        type: 'mcq',
        options: ['2', '1', '2.33', '0'],
        correctAnswer: '1',
        explanation: 'The modulus operator (%) gives the remainder of an integer division. 7 divided by 3 is 2 with a remainder of 1.',
      },
      {
        id: 6,
        text: 'Every statement in a C program must end with a...?',
        type: 'mcq',
        options: ['period (.)', 'colon (:)', 'semicolon (;)', 'comma (,)'],
        correctAnswer: 'semicolon (;)',
        explanation: 'The semicolon acts as a statement terminator, signaling the end of a single instruction to the compiler.',
      },
      {
        id: 7,
        text: 'What is the correct syntax for a single-line comment?',
        type: 'mcq',
        options: ['// This is a comment', '/* This is a comment */', '# This is a comment', '<!-- This is a comment -->'],
        correctAnswer: '// This is a comment',
        explanation: 'In C (from C99 standard onwards), `//` is used for single-line comments. `/* ... */` is used for multi-line comments.',
      },
      {
        id: 8,
        text: 'Which function is the entry point of every C program?',
        type: 'mcq',
        options: ['start()', 'main()', 'begin()', 'program()'],
        correctAnswer: 'main()',
        explanation: 'The execution of a C program starts from the `main()` function.',
      },
      {
        id: 9,
        text: 'What does the `sizeof` operator return?',
        type: 'mcq',
        options: ['The number of elements in an array', 'The size of a variable or data type in bytes', 'The maximum value a variable can hold', 'The memory address of a variable'],
        correctAnswer: 'The size of a variable or data type in bytes',
        explanation: '`sizeof` is a compile-time operator that returns the size (in bytes) of its operand.',
      },
      {
        id: 10,
        text: 'How do you declare a constant in C?',
        type: 'mcq',
        options: ['const int PI = 3.14;', 'constant PI = 3.14;', 'int const PI = 3.14;', 'Both A and C'],
        correctAnswer: 'Both A and C',
        explanation: 'C allows `const` to be placed either before or after the data type. So both `const int ...` and `int const ...` are valid ways to declare a constant.',
      },
      {
        id: 11,
        text: 'Which operator is used to represent logical AND?',
        type: 'mcq',
        options: ['&', '&&', '|', '||'],
        correctAnswer: '&&',
        explanation: '`&&` is the logical AND operator. `&` is the bitwise AND operator.',
      },
      {
        id: 12,
        text: 'Which loop is guaranteed to execute at least once?',
        type: 'mcq',
        options: ['for', 'while', 'do...while', 'None of the above'],
        correctAnswer: 'do...while',
        explanation: 'The `do...while` loop checks its condition at the end of the loop, so the body of the loop is always executed at least once.',
      },
      {
        id: 13,
        text: 'What is the purpose of the `break` statement?',
        type: 'mcq',
        options: ['To exit the program', 'To skip the current iteration of a loop', 'To exit from a loop or switch statement', 'To go to the next case in a switch'],
        correctAnswer: 'To exit from a loop or switch statement',
        explanation: 'The `break` statement terminates the execution of the nearest enclosing loop or switch statement.',
      },
      {
        id: 14,
        text: 'Which data type is used to store a single character?',
        type: 'mcq',
        options: ['char', 'string', 'character', 'alpha'],
        correctAnswer: 'char',
        explanation: 'The `char` data type is used to store a single character value.',
      },
      {
        id: 15,
        text: 'How is a string represented in C?',
        type: 'mcq',
        options: ['Using the String class', 'As an array of characters ending with a null character \'\\0\'', 'Using the `string` keyword', 'As a list of characters'],
        correctAnswer: 'As an array of characters ending with a null character \'\\0\'',
        explanation: 'C does not have a built-in string type. Strings are treated as arrays of characters, terminated by the null character `\\0`.',
      },
      {
        id: 16,
        text: 'What is the function of `scanf`?',
        type: 'mcq',
        options: ['To print formatted output to the console', 'To read formatted input from the console', 'To read a single character', 'To check the size of a variable'],
        correctAnswer: 'To read formatted input from the console',
        explanation: '`scanf` is used to read data from the standard input (usually the keyboard) according to a specified format.',
      },
      {
        id: 17,
        text: 'Which of the following is NOT a valid variable name in C?',
        type: 'mcq',
        options: ['_myVar', 'my_Var', 'my-Var', 'myVar1'],
        correctAnswer: 'my-Var',
        explanation: 'Variable names in C cannot contain hyphens (-). They can only contain letters, digits, and underscores (_).',
      },
      {
        id: 18,
        text: 'What is type casting?',
        type: 'mcq',
        options: ['Converting a variable from one data type to another', 'Creating a new variable', 'A way to comment code', 'A type of operator'],
        correctAnswer: 'Converting a variable from one data type to another',
        explanation: 'Type casting is an explicit conversion of a variable from one data type to another, e.g., `(float)my_integer;`',
      },
      {
        id: 19,
        text: 'Which header file is required for using dynamic memory allocation functions like `malloc`?',
        type: 'mcq',
        options: ['<stdio.h>', '<math.h>', '<stdlib.h>', '<string.h>'],
        correctAnswer: '<stdlib.h>',
        explanation: 'The standard library header `<stdlib.h>` contains declarations for functions like `malloc`, `calloc`, `realloc`, and `free`.',
      },
      {
        id: 20,
        text: 'What will be the value of `x` after `x = 5 + 3 * 2;`?',
        type: 'mcq',
        options: ['16', '11', '13', '10'],
        correctAnswer: '11',
        explanation: 'Operator precedence dictates that multiplication (*) is performed before addition (+). So, 3 * 2 is 6, and 5 + 6 is 11.',
      },
      {
        id: 21,
        text: 'Which operator has the highest precedence in C?',
        type: 'mcq',
        options: ['()', '*', '+', '='],
        correctAnswer: '()',
        explanation: 'Parentheses () for function calls and grouping have the highest precedence among the given options.',
      },
      {
        id: 22,
        text: 'What is the use of the `continue` statement?',
        type: 'mcq',
        options: ['To terminate a loop', 'To skip the rest of the current loop iteration and proceed to the next one', 'To continue to the next case in a switch', 'To halt the program'],
        correctAnswer: 'To skip the rest of the current loop iteration and proceed to the next one',
        explanation: 'The `continue` statement is used inside loops to end the current iteration and begin the next.',
      },
      {
        id: 23,
        text: 'What is the default value of a local variable in C?',
        type: 'mcq',
        options: ['0', 'NULL', 'Garbage value', 'Depends on the data type'],
        correctAnswer: 'Garbage value',
        explanation: 'If a local variable is not explicitly initialized, its value is indeterminate and is referred to as a garbage value.',
      },
      {
        id: 24,
        text: 'Which of the following is a relational operator?',
        type: 'mcq',
        options: ['+', '&&', '==', '='],
        correctAnswer: '==',
        explanation: '`==` (equal to) is a relational operator used for comparison. `=` is the assignment operator.',
      },
      {
        id: 25,
        text: 'How do you define a macro in C?',
        type: 'mcq',
        options: ['#macro PI 3.14', '#define PI 3.14', 'macro PI = 3.14', 'define PI 3.14'],
        correctAnswer: '#define PI 3.14',
        explanation: 'The `#define` preprocessor directive is used to create macros.',
      },
      {
        id: 26,
        text: 'The `void` keyword in a function declaration means...?',
        type: 'mcq',
        options: ['The function is empty', 'The function returns no value', 'The function takes no arguments', 'The function is invalid'],
        correctAnswer: 'The function returns no value',
        explanation: 'When `void` is used as a function return type, it indicates that the function does not return any value.',
      },
      {
        id: 27,
        text: 'What is an array in C?',
        type: 'mcq',
        options: ['A collection of elements of different data types', 'A collection of elements of the same data type', 'A special type of function', 'A keyword'],
        correctAnswer: 'A collection of elements of the same data type',
        explanation: 'An array is a fixed-size, sequential collection of elements of the same data type, stored in contiguous memory locations.',
      },
      {
        id: 28,
        text: 'How do you access the first element of an array named `arr`?',
        type: 'mcq',
        options: ['arr[0]', 'arr[1]', 'arr.first', 'arr(0)'],
        correctAnswer: 'arr[0]',
        explanation: 'Array indexing in C is 0-based, so the first element is at index 0.',
      },
      {
        id: 29,
        text: 'Which of these is the ternary or conditional operator?',
        type: 'mcq',
        options: [':?', '?:', '??', 'if-then-else'],
        correctAnswer: '?:',
        explanation: 'The ternary operator `?:` is a shorthand for an if-else statement. Syntax: `condition ? value_if_true : value_if_false`.',
      },
      {
        id: 30,
        text: 'What does `i++` do?',
        type: 'mcq',
        options: ['Increments `i` then uses its value', 'Uses the value of `i` then increments it', 'It is a syntax error', 'Decrements `i`'],
        correctAnswer: 'Uses the value of `i` then increments it',
        explanation: 'This is the post-increment operator. It uses the current value of the variable in the expression and then increments it.',
      },
      {
        id: 31,
        text: 'What is the difference between `a = 5` and `a == 5`?',
        type: 'mcq',
        options: ['No difference', '`=` is assignment, `==` is comparison', '`=` is comparison, `==` is assignment', '`==` is for floats only'],
        correctAnswer: '`=` is assignment, `==` is comparison',
        explanation: 'The single equals `=` is the assignment operator, which sets the value of a variable. The double equals `==` is the equality operator, which compares two values.',
      },
      {
        id: 32,
        text: 'A `switch` statement can be used with which data types?',
        type: 'mcq',
        options: ['int and char', 'float and double', 'All data types', 'Only int'],
        correctAnswer: 'int and char',
        explanation: 'The controlling expression of a switch statement must be of an integral type, which includes `int`, `char`, and `enum` types.',
      },
      {
        id: 33,
        text: 'What is the purpose of the `default` case in a `switch` statement?',
        type: 'mcq',
        options: ['It is a mandatory first case', 'It executes if none of the other cases match', 'It sets a default value for the variable', 'It is a syntax error'],
        correctAnswer: 'It executes if none of the other cases match',
        explanation: 'The `default` case provides a block of code to be executed if the switch expression does not match any of the `case` labels.',
      },
      {
        id: 34,
        text: 'How is a multi-line comment written in C?',
        type: 'mcq',
        options: ['// comment', '/* comment */', '## comment ##', '<!-- comment -->'],
        correctAnswer: '/* comment */',
        explanation: '`/*` starts a multi-line comment, and `*/` ends it. Anything between them is ignored by the compiler.',
      },
      {
        id: 35,
        text: 'Which standard library function can be used to find the length of a string?',
        type: 'mcq',
        options: ['length()', 'len()', 'strlen()', 'sizeof()'],
        correctAnswer: 'strlen()',
        explanation: 'The `strlen()` function, found in `<string.h>`, returns the length of a string (not including the null terminator).',
      },
      {
        id: 36,
        text: 'A function that calls itself is called a...?',
        type: 'mcq',
        options: ['Recursive function', 'Auto function', 'Static function', 'Looping function'],
        correctAnswer: 'Recursive function',
        explanation: 'Recursion is a programming technique where a function calls itself to solve a problem.',
      },
      {
        id: 37,
        text: 'What is the output of `printf("%d", 10 / 4);`?',
        type: 'mcq',
        options: ['2.5', '3', '2', 'Error'],
        correctAnswer: '2',
        explanation: 'When dividing two integers, C performs integer division, which truncates any fractional part. So, 10 / 4 is 2.',
      },
      {
        id: 38,
        text: 'Which operator is used for bitwise OR?',
        type: 'mcq',
        options: ['|', '||', '&', '&&'],
        correctAnswer: '|',
        explanation: '`|` is the bitwise OR operator. `||` is the logical OR operator.',
      },
      {
        id: 39,
        text: 'In a `for` loop `for(A; B; C)`, which part is the condition?',
        type: 'mcq',
        options: ['A', 'B', 'C', 'All of them'],
        correctAnswer: 'B',
        explanation: 'A is initialization, B is the condition (the loop continues as long as B is true), and C is the post-iteration step (e.g., increment/decrement).',
      },
      {
        id: 40,
        text: 'What is the `enum` keyword used for?',
        type: 'mcq',
        options: ['To create a list of integer constants', 'To declare a floating point number', 'To define a new math function', 'To allocate memory'],
        correctAnswer: 'To create a list of integer constants',
        explanation: 'Enumerations (`enum`) allow for creating a new type and defining a set of named integer constants for it.',
      },
      {
        id: 41,
        text: 'Which of the following shows the correct syntax for a `while` loop?',
        type: 'mcq',
        options: ['while(x>0) { ... }', 'while x>0 { ... }', 'do { ... } while(x>0)', 'for(while x>0) { ... }'],
        correctAnswer: 'while(x>0) { ... }',
        explanation: 'The correct syntax for a while loop is `while (condition) { statement_block }`.',
      },
      {
        id: 42,
        text: 'What does `char c = 65;` store in the variable `c`?',
        type: 'mcq',
        options: ['The number 65', 'The character \'A\'', 'A syntax error', 'The character \'6\''],
        correctAnswer: 'The character \'A\'',
        explanation: 'Characters are represented by their ASCII values. The ASCII value for the character \'A\' is 65.',
      },
      {
        id: 43,
        text: 'Which bitwise operator is suitable for turning a specific bit ON?',
        type: 'mcq',
        options: ['AND (&)', 'OR (|)', 'NOT (~)', 'XOR (^)'],
        correctAnswer: 'OR (|)',
        explanation: 'Performing a bitwise OR with a bit mask where the desired bit is 1 will turn that bit on without affecting others.',
      },
      {
        id: 44,
        text: 'What will `x >> 1` do to an unsigned integer `x`?',
        type: 'mcq',
        options: ['Multiply it by 2', 'Divide it by 2', 'Add 1 to it', 'Result in an error'],
        correctAnswer: 'Divide it by 2',
        explanation: 'The right shift operator `>>` shifts the bits to the right, which is equivalent to integer division by a power of 2.',
      },
      {
        id: 45,
        text: 'Local variables are stored in an area of memory called...?',
        type: 'mcq',
        options: ['The Heap', 'The Stack', 'Permanent storage', 'The Data Segment'],
        correctAnswer: 'The Stack',
        explanation: 'The stack is used for static memory allocation, and local variables are typically stored there.',
      },
      {
        id: 46,
        text: 'The `auto` keyword is implicitly applied to which type of variables?',
        type: 'mcq',
        options: ['Global variables', 'Local variables', 'Static variables', 'All variables'],
        correctAnswer: 'Local variables',
        explanation: 'By default, all local variables have the `auto` storage class, though the keyword itself is rarely used in modern code.',
      },
      {
        id: 47,
        text: 'A variable declared outside of all functions is called a...?',
        type: 'mcq',
        options: ['Local variable', 'Global variable', 'Static variable', 'Constant variable'],
        correctAnswer: 'Global variable',
        explanation: 'Global variables are declared outside any function and are accessible from any function within the entire program.',
      },
      {
        id: 48,
        text: 'What is the value of `EOF`?',
        type: 'mcq',
        options: ['A positive integer', 'Zero', 'A negative integer', 'A character'],
        correctAnswer: 'A negative integer',
        explanation: 'EOF (End-Of-File) is a macro defined in `<stdio.h>` that represents a non-character value returned by I/O functions to indicate the end of a file or stream. It\'s a negative integer.',
      },
      {
        id: 49,
        text: 'What is the result of `! (1 && 0)`?',
        type: 'mcq',
        options: ['1 (true)', '0 (false)', 'Undefined', '-1'],
        correctAnswer: '1 (true)',
        explanation: '`1 && 0` evaluates to 0 (false). The logical NOT operator `!` then inverts this to 1 (true).',
      },
      {
        id: 50,
        text: 'Which keyword is used to prevent a variable from being modified?',
        type: 'mcq',
        options: ['static', 'extern', 'const', 'final'],
        correctAnswer: 'const',
        explanation: 'The `const` keyword makes a variable read-only, so its value cannot be changed after initialization.',
      },
      {
        id: 51,
        text: 'What is the format specifier for a long integer?',
        type: 'mcq',
        options: ['%d', '%ld', '%Ld', '%s'],
        correctAnswer: '%ld',
        explanation: '`%ld` is used for `long int`, and `%lld` is used for `long long int`.',
      },
      {
        id: 52,
        text: 'Which function is used to concatenate two strings?',
        type: 'mcq',
        options: ['strcat()', 'strcpy()', 'strcmp()', 'strlen()'],
        correctAnswer: 'strcat()',
        explanation: '`strcat()` (string concatenation) appends one string to the end of another.',
      },
      {
        id: 53,
        text: 'What is the correct syntax to initialize all elements of an integer array of size 10 to 0?',
        type: 'mcq',
        options: ['int arr[10] = {0};', 'int arr[10] = 0;', 'int arr[10](0);', 'int arr[10]; arr = 0;'],
        correctAnswer: 'int arr[10] = {0};',
        explanation: 'When initializing an array, if you provide fewer initializers than elements, the remaining elements are automatically initialized to zero.',
      },
      {
        id: 54,
        text: 'A C preprocessor directive always begins with which character?',
        type: 'mcq',
        options: ['$', '#', '&', '%'],
        correctAnswer: '#',
        explanation: 'Preprocessor directives like #include, #define, and #if all start with the hash symbol.',
      },
      {
        id: 55,
        text: 'Which of the following is an exit-controlled loop?',
        type: 'mcq',
        options: ['for', 'while', 'do-while', 'if-else'],
        correctAnswer: 'do-while',
        explanation: 'An exit-controlled loop checks the condition after the loop body is executed. `do-while` is the only one that does this.',
      },
      {
        id: 56,
        text: 'What is the purpose of the `return 0;` statement in the `main` function?',
        type: 'mcq',
        options: ['It returns the value 0 to the calling function.', 'It indicates the program executed successfully.', 'It stops the program.', 'It is a syntax requirement with no real meaning.'],
        correctAnswer: 'It indicates the program executed successfully.',
        explanation: 'By convention, a return value of 0 from `main` indicates that the program terminated without errors.',
      },
      {
        id: 57,
        text: 'What is the range of the `char` data type?',
        type: 'mcq',
        options: ['-128 to 127', '0 to 255', '0 to 65535', 'Depends on the compiler'],
        correctAnswer: '-128 to 127',
        explanation: 'A `signed char` typically has a range of -128 to 127. An `unsigned char` has a range of 0 to 255.',
      },
      {
        id: 58,
        text: 'Which function prototype is valid in C?',
        type: 'mcq',
        options: ['function myFunc();', 'int myFunc();', 'myFunc() int;', 'def myFunc(): int'],
        correctAnswer: 'int myFunc();',
        explanation: 'A function prototype must specify the return type, the function name, and optionally the parameter types. `int myFunc();` is a valid prototype for a function returning an integer.',
      },
      {
        id: 59,
        text: 'What does the `&` operator do when used in `scanf`? For example: `scanf("%d", &num);`',
        type: 'mcq',
        options: ['It dereferences the variable `num`.', 'It passes the value of `num`.', 'It passes the memory address of `num`.', 'It creates a copy of `num`.'],
        correctAnswer: 'It passes the memory address of `num`.',
        explanation: '`scanf` needs the memory address of the variable to store the input value. The address-of operator `&` provides this.',
      },
      {
        id: 60,
        text: 'Which data structure is implemented by an array?',
        type: 'mcq',
        options: ['Linked List', 'Stack', 'Tree', 'Graph'],
        correctAnswer: 'Stack',
        explanation: 'While an array is a basic data structure itself, it is commonly used to implement other linear data structures like stacks and queues.',
      },
      {
        id: 61,
        text: 'What is the ASCII value of the null character `\\0`?',
        type: 'mcq',
        options: ['65', '48', '32', '0'],
        correctAnswer: '0',
        explanation: 'The null character, used to terminate strings, has an ASCII value of 0.',
      },
      {
        id: 62,
        text: 'The `extern` keyword is used to...?',
        type: 'mcq',
        options: ['Declare a variable that is defined in another file.', 'Make a variable local.', 'Make a variable constant.', 'Allocate memory externally.'],
        correctAnswer: 'Declare a variable that is defined in another file.',
        explanation: '`extern` provides a reference to a global variable that is defined elsewhere, typically in another source file.',
      },
      {
        id: 63,
        text: 'What is the output of `(float)10 / 4`?',
        type: 'mcq',
        options: ['2', '2.000000', '2.500000', '3'],
        correctAnswer: '2.500000',
        explanation: 'Casting one of the integers to a float forces the operation to be floating-point division, resulting in a non-truncated answer.',
      },
      {
        id: 64,
        text: 'If `int a = 10, b = 20;`, what is the value of `a > b ? a : b;`?',
        type: 'mcq',
        options: ['10', '20', 'true', 'false'],
        correctAnswer: '20',
        explanation: 'The ternary operator checks if `a > b`. Since 10 is not greater than 20, the condition is false, and the expression evaluates to the value after the colon, which is `b` (20).',
      },
      {
        id: 65,
        text: 'Which header file should you include to use functions like `sqrt()` and `pow()`?',
        type: 'mcq',
        options: ['<stdlib.h>', '<stdio.h>', '<math.h>', '<conio.h>'],
        correctAnswer: '<math.h>',
        explanation: 'The `<math.h>` header file contains declarations for common mathematical functions.',
      },
      {
        id: 66,
        text: 'What is a "dangling pointer"?',
        type: 'mcq',
        options: ['A pointer that points to a valid memory location.', 'A pointer initialized to NULL.', 'A pointer that points to a memory location that has been freed.', 'A pointer that has not been initialized.'],
        correctAnswer: 'A pointer that points to a memory location that has been freed.',
        explanation: 'A dangling pointer arises when you deallocate a block of memory, but still have a pointer that points to where that memory used to be. Using it can cause crashes or undefined behavior.',
      },
      {
        id: 67,
        text: 'The `static` keyword applied to a local variable means...?',
        type: 'mcq',
        options: ['The variable cannot be changed.', 'The variable is visible only within that file.', 'The variable retains its value between function calls.', 'The variable is created on the heap.'],
        correctAnswer: 'The variable retains its value between function calls.',
        explanation: 'A static local variable is initialized only once and keeps its value across multiple calls to the function.',
      },
      {
        id: 68,
        text: 'Which of the following is NOT a fundamental data type in C?',
        type: 'mcq',
        options: ['int', 'float', 'string', 'char'],
        correctAnswer: 'string',
        explanation: 'C does not have a native `string` data type. Strings are handled as arrays of characters.',
      },
      {
        id: 69,
        text: 'What is the primary difference between a `struct` and a `union`?',
        type: 'mcq',
        options: ['`struct` can have functions, `union` cannot.', 'All members of a `struct` are stored in separate memory locations, while `union` members share the same memory location.', '`struct` is a keyword, `union` is not.', 'There is no difference.'],
        correctAnswer: 'All members of a `struct` are stored in separate memory locations, while `union` members share the same memory location.',
        explanation: 'A `union` is only as large as its largest member, as all members occupy the same memory space. A `struct` is the size of all its members combined.',
      },
      {
        id: 70,
        text: 'The `goto` statement causes...',
        type: 'mcq',
        options: ['the program to terminate.', 'the program to jump to a labeled statement.', 'the current function to exit.', 'the next iteration of a loop to start.'],
        correctAnswer: 'the program to jump to a labeled statement.',
        explanation: '`goto` provides an unconditional jump to a labeled statement within the same function. Its use is generally discouraged in favor of structured control flow.',
      },
      {
        id: 71,
        text: 'What will `x << 2` do to an unsigned integer `x`?',
        type: 'mcq',
        options: ['Divide it by 4', 'Multiply it by 4', 'Add 2 to it', 'Subtract 2 from it'],
        correctAnswer: 'Multiply it by 4',
        explanation: 'The left shift operator `<< n` is equivalent to multiplying by 2^n. So, `x << 2` is equivalent to `x * 4`.',
      },
      {
        id: 72,
        text: 'Which of the following is a valid way to initialize a character array with a string?',
        type: 'mcq',
        options: ['char str[] = "hello";', 'char str[5] = "hello";', 'char str[]; str = "hello";', 'char str(5) = "hello";'],
        correctAnswer: 'char str[] = "hello";',
        explanation: '`char str[] = "hello";` correctly initializes the array with the string literal, automatically sizing the array to 6 characters (5 for "hello" + 1 for \'\\0\'). `char str[5] = "hello";` would not leave room for the null terminator.',
      },
      {
        id: 73,
        text: 'What is the purpose of `typedef`?',
        type: 'mcq',
        options: ['To define a new variable.', 'To create an alias for an existing data type.', 'To check the type of a variable.', 'To perform type casting.'],
        correctAnswer: 'To create an alias for an existing data type.',
        explanation: '`typedef` is used to give a new name to an existing data type, which can improve code readability. For example, `typedef unsigned char BYTE;`',
      },
      {
        id: 74,
        text: 'The bitwise XOR operator is represented by...?',
        type: 'mcq',
        options: ['~', '&', '|', '^'],
        correctAnswer: '^',
        explanation: 'The `^` character is used for the bitwise XOR operation.',
      },
      {
        id: 75,
        text: 'What is the value of `x` after the following code? `int x = 10; x += 5;`',
        type: 'mcq',
        options: ['10', '5', '15', 'Error'],
        correctAnswer: '15',
        explanation: 'The `+=` operator is a compound assignment operator. `x += 5` is shorthand for `x = x + 5`.',
      },
      {
        id: 76,
        text: 'Which function is used to copy one string to another?',
        type: 'mcq',
        options: ['strcat()', 'strcpy()', 'strcopy()', 'strassign()'],
        correctAnswer: 'strcpy()',
        explanation: 'The `strcpy()` function from `<string.h>` is used to copy the contents of one string into another.',
      },
      {
        id: 77,
        text: 'An uninitialized pointer is known as a...?',
        type: 'mcq',
        options: ['Null pointer', 'Dangling pointer', 'Void pointer', 'Wild pointer'],
        correctAnswer: 'Wild pointer',
        explanation: 'A wild pointer points to an arbitrary, unknown memory location because it was not initialized. Using it is dangerous.',
      },
      {
        id: 78,
        text: 'What does the function `getchar()` do?',
        type: 'mcq',
        options: ['Prints a character to the screen', 'Reads a single character from the standard input', 'Reads a full string', 'Returns a random character'],
        correctAnswer: 'Reads a single character from the standard input',
        explanation: '`getchar()` reads the next character from stdin and returns it as an integer.',
      },
      {
        id: 79,
        text: 'Which is the correct order of evaluation for logical operators?',
        type: 'mcq',
        options: ['AND, OR, NOT', 'NOT, AND, OR', 'OR, AND, NOT', 'They have the same precedence'],
        correctAnswer: 'NOT, AND, OR',
        explanation: 'The logical NOT `!` has the highest precedence, followed by logical AND `&&`, and finally logical OR `||`.',
      },
      {
        id: 80,
        text: 'What is `argc` in the `main` function `int main(int argc, char *argv[])`?',
        type: 'mcq',
        options: ['Argument character count', 'Argument count', 'Argument check', 'A pointer to the arguments'],
        correctAnswer: 'Argument count',
        explanation: '`argc` is an integer that holds the number of command-line arguments passed to the program, including the program name itself.',
      },
      {
        id: 81,
        text: 'What is `argv` in the `main` function `int main(int argc, char *argv[])`?',
        type: 'mcq',
        options: ['A list of argument values', 'An array of character pointers (strings)', 'Argument version', 'The return value'],
        correctAnswer: 'An array of character pointers (strings)',
        explanation: '`argv` is an "argument vector". It is an array of pointers to strings, where each string is one of the command-line arguments.',
      },
      {
        id: 82,
        text: 'What does `++i` do?',
        type: 'mcq',
        options: ['Increments `i` then uses its new value', 'Uses the value of `i` then increments it', 'It is a syntax error', 'It is the same as `i++`'],
        correctAnswer: 'Increments `i` then uses its new value',
        explanation: 'This is the pre-increment operator. It increments the value of the variable first and then uses the new value in the expression.',
      },
      {
        id: 83,
        text: 'In C, what is the size of the `double` data type?',
        type: 'mcq',
        options: ['4 bytes', '8 bytes', '2 bytes', 'Depends on the system'],
        correctAnswer: '8 bytes',
        explanation: 'While sizes can technically be system-dependent, a `double` is almost universally 8 bytes on modern systems, providing double the precision of a `float`.',
      },
      {
        id: 84,
        text: 'The modulus operator `%` can be used with which data types?',
        type: 'mcq',
        options: ['int only', 'float only', 'int and float', 'All data types'],
        correctAnswer: 'int only',
        explanation: 'The modulus operator is defined only for integer operands in C.',
      },
      {
        id: 85,
        text: 'What is the value of `(5 < 3) && (3 > 2)`?',
        type: 'mcq',
        options: ['1', '0', 'True', 'Error'],
        correctAnswer: '0',
        explanation: 'The logical AND `&&` uses short-circuit evaluation. Since `(5 < 3)` is false (0), the second part of the expression is not evaluated, and the result is 0 (false).',
      },
      {
        id: 86,
        text: 'What is the function `strcmp()` used for?',
        type: 'mcq',
        options: ['To copy a string', 'To combine two strings', 'To compare two strings', 'To find the length of a string'],
        correctAnswer: 'To compare two strings',
        explanation: '`strcmp()` compares two strings lexicographically and returns 0 if they are equal, a negative value if the first string is less than the second, and a positive value otherwise.',
      },
      {
        id: 87,
        text: 'Which function would you use to allocate memory for an array and initialize it to zero?',
        type: 'mcq',
        options: ['malloc()', 'realloc()', 'calloc()', 'free()'],
        correctAnswer: 'calloc()',
        explanation: '`calloc()` (contiguous allocation) allocates memory for a number of elements of a certain size and initializes all bytes in the allocated memory to zero.',
      },
      {
        id: 88,
        text: 'What is the correct way to pass an array to a function?',
        type: 'mcq',
        options: ['By passing the array as a pointer', 'By copying the entire array', 'It is not possible to pass arrays', 'By using the `&` operator on the array name'],
        correctAnswer: 'By passing the array as a pointer',
        explanation: 'When you pass an array to a function, what is actually passed is a pointer to the first element of the array.',
      },
      {
        id: 89,
        text: 'In the expression `p->m`, `p` must be a...?',
        type: 'mcq',
        options: ['struct or union variable', 'pointer to a struct or union', 'integer', 'array name'],
        correctAnswer: 'pointer to a struct or union',
        explanation: 'The arrow operator `->` is used to access members of a `struct` or `union` via a pointer to that `struct` or `union`.',
      },
      {
        id: 90,
        text: 'What is the bitwise complement operator?',
        type: 'mcq',
        options: ['!', '~', '^', '&'],
        correctAnswer: '~',
        explanation: 'The tilde `~` is the bitwise NOT or complement operator. It flips every bit in its operand.',
      },
      {
        id: 91,
        text: 'What is `void *`?',
        type: 'mcq',
        options: ['A pointer to nothing', 'An invalid pointer', 'A generic pointer that can point to any data type', 'A pointer to a function that returns nothing'],
        correctAnswer: 'A generic pointer that can point to any data type',
        explanation: 'A `void` pointer is a generic pointer that can hold the address of any data type. It must be cast to another pointer type before being dereferenced.',
      },
      {
        id: 92,
        text: 'How can you find out the number of elements in an array `arr` if the size is known at compile time?',
        type: 'mcq',
        options: ['`sizeof(arr)`', '`sizeof(arr) / sizeof(arr[0])`', '`strlen(arr)`', 'It is not possible'],
        correctAnswer: '`sizeof(arr) / sizeof(arr[0])`',
        explanation: 'This expression divides the total size of the array in bytes by the size of a single element in bytes, yielding the number of elements.',
      },
      {
        id: 93,
        text: 'Which header file is necessary to use the `isalpha()` function?',
        type: 'mcq',
        options: ['<stdio.h>', '<stdlib.h>', '<string.h>', '<ctype.h>'],
        correctAnswer: '<ctype.h>',
        explanation: 'The `<ctype.h>` header contains functions for testing and mapping characters, such as `isalpha()`, `isdigit()`, `isspace()`, etc.',
      },
    ],
  },
  {
    id: 'c-pointers-1',
    title: 'Pointers in C',
    description: 'Dive into the world of pointers and memory management.',
    difficulty: 'Medium',
    questions: [
      {
        id: 1,
        text: 'Which operator is used to get the memory address of a variable?',
        type: 'mcq',
        options: ['*', '&', '->', '.'],
        correctAnswer: '&',
        explanation: 'The `&` (ampersand) operator is the "address-of" operator. It returns the memory address of a variable.',
      },
      {
        id: 2,
        text: 'What will be the output of this code?',
        type: 'code',
        codeSnippet: '#include <stdio.h>\n\nint main() {\n    int var = 10;\n    int *p;\n    p = &var;\n    printf("%d", *p);\n    return 0;\n}',
        correctAnswer: '10',
        explanation: 'The pointer `p` holds the address of `var`. The `*p` dereferences the pointer, giving the value stored at that address, which is 10.',
      },
      {
        id: 3,
        text: 'A pointer that is not assigned to any variable is called a...?',
        type: 'mcq',
        options: ['Null Pointer', 'Void Pointer', 'Wild Pointer', 'Dangling Pointer'],
        correctAnswer: 'Wild Pointer',
        explanation: 'A wild pointer is a pointer that has not been initialized. Attempting to use it can lead to unpredictable behavior.',
      },
      {
        id: 4,
        text: 'Which operator is used to get the value stored at the address a pointer is pointing to?',
        type: 'mcq',
        options: ['*', '&', '->', '#'],
        correctAnswer: '*',
        explanation: 'The `*` (asterisk) operator is the "dereference" or "indirection" operator. It returns the value of the variable located at the address specified by the pointer.',
      },
      {
        id: 5,
        text: 'How do you declare a pointer to an integer?',
        type: 'mcq',
        options: ['`pointer int p;`', '`int p*`', '`int *p;`', '`int &p;`'],
        correctAnswer: '`int *p;`',
        explanation: 'The syntax for declaring a pointer is `data_type *pointer_name;`. The asterisk indicates that it is a pointer.',
      },
      {
        id: 6,
        text: 'What is a NULL pointer?',
        type: 'mcq',
        options: ['A pointer that points to address 0.', 'A pointer that points to a special value, indicating it doesn\'t point to any valid memory.', 'A pointer that has been deleted.', 'An uninitialized pointer.'],
        correctAnswer: 'A pointer that points to a special value, indicating it doesn\'t point to any valid memory.',
        explanation: 'A NULL pointer is a special pointer value that is guaranteed not to point to any valid object or function. It\'s often defined as `(void*)0`.',
      },
      {
        id: 7,
        text: 'If `int *p;`, what does `p++` do, assuming `sizeof(int)` is 4?',
        type: 'mcq',
        options: ['Increments the value at address `p` by 1.', 'Increments the address stored in `p` by 1 byte.', 'Increments the address stored in `p` by 4 bytes.', 'It is a syntax error.'],
        correctAnswer: 'Increments the address stored in `p` by 4 bytes.',
        explanation: 'Pointer arithmetic is scaled by the size of the data type it points to. `p++` increments the pointer to point to the next integer, so it adds `sizeof(int)` to the address.',
      },
      {
        id: 8,
        text: 'What is a dangling pointer?',
        type: 'mcq',
        options: ['A pointer initialized to NULL.', 'A pointer that points to a memory location that has been deallocated (freed).', 'A pointer that has not been initialized.', 'A pointer to a pointer.'],
        correctAnswer: 'A pointer that points to a memory location that has been deallocated (freed).',
        explanation: 'This occurs when `free()` is called on a memory block, but the pointer to it is not set to NULL. The pointer still "dangles," pointing to invalid memory.',
      },
      {
        id: 9,
        text: 'What is the output of this code?',
        type: 'code',
        codeSnippet: '#include <stdio.h>\n\nint main() {\n    int arr[] = {10, 20, 30};\n    int *p = arr;\n    printf("%d", *(p + 1));\n    return 0;\n}',
        correctAnswer: '20',
        explanation: 'The name of an array decays to a pointer to its first element. So `p` points to `arr[0]`. `*(p + 1)` points to the next element, `arr[1]`, and dereferences it to get the value 20.',
      },
      {
        id: 10,
        text: 'A pointer that can point to any data type is a...?',
        type: 'mcq',
        options: ['`int` pointer', '`char` pointer', '`void` pointer', '`null` pointer'],
        correctAnswer: '`void` pointer',
        explanation: 'A `void *` is a generic pointer that can hold the address of any type of variable. It must be explicitly cast before dereferencing.',
      },
      {
        id: 11,
        text: 'What is the purpose of the `free()` function?',
        type: 'mcq',
        options: ['To free a variable from its value.', 'To release a block of memory previously allocated by `malloc`, `calloc`, or `realloc`.', 'To set a pointer to NULL.', 'To delete a file.'],
        correctAnswer: 'To release a block of memory previously allocated by `malloc`, `calloc`, or `realloc`.',
        explanation: '`free()` deallocates the memory, returning it to the heap so it can be reused by future allocations.',
      },
      {
        id: 12,
        text: 'What does `const int *p` declare?',
        type: 'mcq',
        options: ['A constant pointer to an integer.', 'A pointer to a constant integer.', 'A constant pointer to a constant integer.', 'A syntax error.'],
        correctAnswer: 'A pointer to a constant integer.',
        explanation: 'The value pointed to by `p` (`*p`) cannot be changed, but the pointer `p` itself can be changed to point to another integer.',
      },
      {
        id: 13,
        text: 'What does `int * const p` declare?',
        type: 'mcq',
        options: ['A constant pointer to an integer.', 'A pointer to a constant integer.', 'A constant pointer to a constant integer.', 'A syntax error.'],
        correctAnswer: 'A constant pointer to an integer.',
        explanation: 'The pointer `p` itself is constant and cannot be changed to point to another address, but the value it points to (`*p`) can be modified.',
      },
      {
        id: 14,
        text: 'In the expression `p->member`, `p` must be a...?',
        type: 'mcq',
        options: ['A struct variable.', 'An array name.', 'A pointer to a struct or union.', 'A union variable.'],
        correctAnswer: 'A pointer to a struct or union.',
        explanation: 'The arrow `->` operator is a shorthand for dereferencing a pointer to a struct/union and then accessing a member. `p->member` is equivalent to `(*p).member`.',
      },
      {
        id: 15,
        text: 'How do you declare a pointer to a function that takes an `int` and returns an `int`?',
        type: 'mcq',
        options: ['`int (*p)(int);`', '`int *p(int);`', '`int (*p(int));`', '`p(int) *int;`'],
        correctAnswer: '`int (*p)(int);`',
        explanation: 'The parentheses around `*p` are crucial. `int *p(int);` would declare a function `p` that takes an `int` and returns a pointer to an `int`.',
      },
      {
        id: 16,
        text: 'What is the size of a pointer variable?',
        type: 'mcq',
        options: ['2 bytes', '4 bytes', 'The size of the data type it points to.', 'Depends on the system architecture (e.g., 4 bytes on 32-bit, 8 bytes on 64-bit).'],
        correctAnswer: 'Depends on the system architecture (e.g., 4 bytes on 32-bit, 8 bytes on 64-bit).',
        explanation: 'A pointer stores a memory address, so its size depends on the address space of the target machine architecture.',
      },
      {
        id: 17,
        text: 'Which function allocates memory for an array of elements and initializes them to zero?',
        type: 'mcq',
        options: ['`malloc()`', '`alloc()`', '`realloc()`', '`calloc()`'],
        correctAnswer: '`calloc()`',
        explanation: '`calloc` (contiguous allocation) takes two arguments: number of elements and size of each element. It allocates the memory and also initializes all bits to zero.',
      },
      {
        id: 18,
        text: 'What is the relationship between arrays and pointers in C?',
        type: 'mcq',
        options: ['They are completely different concepts.', 'An array name is a constant pointer to the first element.', 'A pointer is an array of memory addresses.', 'They are interchangeable in all situations.'],
        correctAnswer: 'An array name is a constant pointer to the first element.',
        explanation: 'In most expressions, an array name decays into a pointer to its first element. This is why pointer arithmetic works so well with arrays.',
      },
      {
        id: 19,
        text: 'What is a "pointer to a pointer"?',
        type: 'mcq',
        options: ['A syntax error.', 'A pointer that stores the address of another pointer.', 'A special type of array.', 'Another name for a void pointer.'],
        correctAnswer: 'A pointer that stores the address of another pointer.',
        explanation: 'Declared as `int **p;`, a double pointer is used to indirectly access and modify another pointer, which is useful for passing pointers to functions by reference.',
      },
      {
        id: 20,
        text: 'What is the output of this code?',
        type: 'code',
        codeSnippet: '#include <stdio.h>\n\nvoid change(int *n) {\n    *n = 20;\n}\n\nint main() {\n    int x = 10;\n    change(&x);\n    printf("%d", x);\n    return 0;\n}',
        correctAnswer: '20',
        explanation: 'The address of `x` is passed to the `change` function. The function then dereferences the pointer to change the value of the original variable `x` to 20. This is known as pass-by-reference.',
      },
      {
        id: 21,
        text: 'If `char *str = "Hello";`, what does `*(str+1)` evaluate to?',
        type: 'mcq',
        options: ['`e`', '`H`', 'The address of `e`', 'Garbage value'],
        correctAnswer: '`e`',
        explanation: '`str` points to the first character \'H\'. `str+1` points to the next character \'e\'. The dereference operator `*` gets the value at that address, which is the character \'e\'.',
      },
      {
        id: 22,
        text: 'What is `arr` equivalent to in most contexts, if `int arr[10];`?',
        type: 'mcq',
        options: ['`*arr`', '`&arr[0]`', '`arr[0]`', '`&arr`'],
        correctAnswer: '`&arr[0]`',
        explanation: 'The name of an array decays to a pointer to its first element. So `arr` is equivalent to the address of its first element, `&arr[0]`.',
      },
      {
        id: 23,
        text: 'What happens if you try to `free()` a pointer that was not allocated with `malloc`/`calloc`/`realloc`?',
        type: 'mcq',
        options: ['The program compiles with an error.', 'The program runs but with a warning.', 'It is safe and does nothing.', 'It results in undefined behavior, which can cause a crash.'],
        correctAnswer: 'It results in undefined behavior, which can cause a crash.',
        explanation: '`free()` should only be used on pointers that point to memory allocated from the heap. Freeing other pointers (e.g., to stack variables) is a serious error.',
      },
      {
        id: 24,
        text: 'What is `&arr` if `int arr[10];`?',
        type: 'mcq',
        options: ['A pointer to the first element (`int *`).', 'A pointer to the whole array (`int (*)[10]`).', 'The same as `arr`.', 'A syntax error.'],
        correctAnswer: 'A pointer to the whole array (`int (*)[10]`).',
        explanation: 'While `&arr` and `arr` may have the same numerical address value, they have different types. `&arr` is a pointer to an array of 10 integers. `(&arr + 1)` would point to the memory location after the entire array.',
      },
      {
        id: 25,
        text: 'Can you subtract one pointer from another?',
        type: 'mcq',
        options: ['No, it is never allowed.', 'Yes, but only if they point to elements of the same array.', 'Yes, it gives the sum of the addresses.', 'Yes, it gives the average of the addresses.'],
        correctAnswer: 'Yes, but only if they point to elements of the same array.',
        explanation: 'Subtracting two pointers that point into the same array gives the number of elements separating them as a `ptrdiff_t` type.',
      },
      {
        id: 26,
        text: 'What is a memory leak?',
        type: 'mcq',
        options: ['When a pointer points to invalid memory.', 'When a program keeps allocating memory from the heap without freeing it.', 'When a program tries to access memory it doesn\'t own.', 'When a pointer is not initialized.'],
        correctAnswer: 'When a program keeps allocating memory from the heap without freeing it.',
        explanation: 'A memory leak occurs when dynamically allocated memory is no longer needed but is not released, making it unavailable for future use and causing the program\'s memory footprint to grow.',
      },
      {
        id: 27,
        text: 'What does `realloc(ptr, 0)` do?',
        type: 'mcq',
        options: ['It is equivalent to `free(ptr)`.', 'It causes an error.', 'It doubles the size of the memory block.', 'It does nothing.'],
        correctAnswer: 'It is equivalent to `free(ptr)`.',
        explanation: 'Calling `realloc` with a new size of 0 is equivalent to calling `free` on the pointer and it returns NULL.',
      },
      {
        id: 28,
        text: 'In `int *p = (int*) malloc(sizeof(int));`, what is the purpose of the cast `(int*)`?',
        type: 'mcq',
        options: ['It is mandatory in C for `malloc` to work.', 'It is good practice in C++ but optional in C.', 'It is required to convert the return type of `malloc` from `void *` to `int *`.', 'It is required only for arrays.'],
        correctAnswer: 'It is good practice in C++ but optional in C.',
        explanation: 'In C, a `void*` can be implicitly converted to any other pointer type, so the cast is not strictly necessary. However, it is required in C++, so many programmers include it for compatibility and clarity.',
      },
      {
        id: 29,
        text: 'What will be printed?',
        type: 'code',
        codeSnippet: '#include <stdio.h>\n\nint main() {\n    int a = 10;\n    void *p = &a;\n    printf("%d", *(int*)p);\n    return 0;\n}',
        correctAnswer: '10',
        explanation: 'A `void` pointer `p` holds the address of `a`. Before dereferencing, it must be cast to the correct type (`int*`). The code correctly casts it and then dereferences it, printing 10.',
      },
      {
        id: 30,
        text: 'Which is true about `const int * const p;`?',
        type: 'mcq',
        options: ['The pointer is constant, the value is not.', 'The value is constant, the pointer is not.', 'Both the pointer and the value it points to are constant.', 'It is an invalid declaration.'],
        correctAnswer: 'Both the pointer and the value it points to are constant.',
        explanation: 'This declares a constant pointer to a constant integer. Neither the pointer itself nor the integer value it points to can be changed.',
      },
      {
        id: 31,
        text: 'What happens when `p - q` is performed, where `p` and `q` are pointers?',
        type: 'mcq',
        options: ['The number of bytes between `p` and `q` is returned.', 'A compile error occurs.', 'The difference is scaled by `sizeof(*p)`.', 'The difference is divided by `sizeof(p) - sizeof(q)`.'],
        correctAnswer: 'The difference is scaled by `sizeof(*p)`.',
        explanation: 'The result of pointer subtraction is the number of elements between the two pointers, not the number of bytes. The byte difference is divided by the size of the element type.',
      },
      {
        id: 32,
        text: 'Is `&a[i]` equivalent to `a+i` for an array `a`?',
        type: 'mcq',
        options: ['Yes, always.', 'No, never.', 'Only if `i` is 0.', 'Only if `a` is a pointer.'],
        correctAnswer: 'Yes, always.',
        explanation: '`a[i]` is defined as `*(a+i)`. Therefore, `&a[i]` is `&(*(a+i))`, and the `&` and `*` operators cancel each other out, leaving `a+i`.',
      },
      {
        id: 33,
        text: 'What is the type of the `NULL` macro?',
        type: 'mcq',
        options: ['`int`', '`void *`', '`char *`', 'Implementation-defined'],
        correctAnswer: 'Implementation-defined',
        explanation: '`NULL` expands to an implementation-defined null pointer constant. It is often `((void*)0)`, but can also be just `0` in a null pointer context.',
      },
      {
        id: 34,
        text: 'Can a pointer point to a specific bit, rather than a byte?',
        type: 'mcq',
        options: ['Yes, using a special bit-pointer type.', 'No, pointers can only address byte-sized memory locations.', 'Yes, by using bit-fields.', 'Only on certain hardware.'],
        correctAnswer: 'No, pointers can only address byte-sized memory locations.',
        explanation: 'The smallest addressable unit of memory in C is a byte. To manipulate individual bits, you must use bitwise operators on a whole byte.',
      },
      {
        id: 35,
        text: 'What is the output?',
        type: 'code',
        codeSnippet: '#include <stdio.h>\n\nint main() {\n    char s[] = "hello";\n    char *p = s;\n    printf("%c, %c", p[0], s[0]);\n    return 0;\n}',
        correctAnswer: 'h, h',
        explanation: 'The pointer `p` points to the start of the string `s`. The array subscript operator `[]` can be used on pointers as well as arrays, so `p[0]` is equivalent to `s[0]`.',
      },
      {
        id: 36,
        text: 'A `char *argv[]` in `main` is equivalent to:',
        type: 'mcq',
        options: ['`char **argv`', '`char *argv`', '`char argv**`', '`char argv[][]`'],
        correctAnswer: '`char **argv`',
        explanation: 'An array of pointers (`char *[]`) is equivalent to a pointer to a pointer (`char **`) when passed as a function argument.',
      },
      {
        id: 37,
        text: 'If `p` is a pointer, what does `*p++` do?',
        type: 'mcq',
        options: ['Increments the pointer `p`, then returns the value at the new address.', 'Returns the value at the address of `p`, then increments the value.', 'Returns the value at the address of `p`, then increments the pointer `p`.', 'Increments the value at the address of `p`.'],
        correctAnswer: 'Returns the value at the address of `p`, then increments the pointer `p`.',
        explanation: 'Due to operator precedence, the postfix `++` has higher precedence than `*`. However, because it is a *postfix* operator, the original address is dereferenced first, and then the pointer `p` is incremented afterwards.',
      },
      {
        id: 38,
        text: 'What is "pointer decay"?',
        type: 'mcq',
        options: ['When a pointer becomes NULL.', 'The process of a pointer losing its type.', 'The implicit conversion of an array name to a pointer to its first element.', 'When `free()` is called on a pointer.'],
        correctAnswer: 'The implicit conversion of an array name to a pointer to its first element.',
        explanation: 'In most expressions, an expression that has array type is converted to a pointer to the first element of the array.',
      },
      {
        id: 39,
        text: 'What does `realloc(NULL, size)` do?',
        type: 'mcq',
        options: ['It causes an error.', 'It returns NULL.', 'It is equivalent to `malloc(size)`.', 'It allocates `size` + `NULL` bytes.'],
        correctAnswer: 'It is equivalent to `malloc(size)`.',
        explanation: 'If the pointer passed to `realloc` is NULL, it behaves exactly like `malloc`, allocating a new block of the specified size.',
      },
      {
        id: 40,
        text: 'Which of these is the most common and safe way to initialize a pointer?',
        type: 'mcq',
        options: ['`int *p;`', '`int *p = 0;`', '`int *p = NULL;`', '`int *p = 1;`'],
        correctAnswer: '`int *p = NULL;`',
        explanation: 'Initializing a pointer to `NULL` is the standard and portable way to ensure it has a well-defined, non-garbage value that can be safely checked before use.',
      },
      {
        id: 41,
        text: 'Is it possible to have an array of pointers?',
        type: 'mcq',
        options: ['No, that is not allowed in C.', 'Yes, for example `int *arr[10];`', 'Only if they are `void` pointers.', 'Only for `char` pointers.'],
        correctAnswer: 'Yes, for example `int *arr[10];`',
        explanation: 'Yes, you can create arrays of any type, including pointer types. `int *arr[10];` declares an array of 10 pointers to integers. `argv` in `main` is a classic example.',
      },
      {
        id: 42,
        text: 'What is the output of this code?',
        type: 'code',
        codeSnippet: '#include <stdio.h>\n\nint main() {\n    int x = 5;\n    int *p = &x;\n    int **q = &p;\n    printf("%d", **q);\n    return 0;\n}',
        correctAnswer: '5',
        explanation: '`p` points to `x`. `q` points to `p`. `*q` dereferences `q` to get `p`. `**q` dereferences `*q` (which is `p`) to get the value of `x`, which is 5.',
      },
      {
        id: 43,
        text: 'Function pointers are often used for...',
        type: 'mcq',
        options: ['Storing numeric values.', 'Implementing callback mechanisms.', 'Replacing `if-else` statements.', 'Managing strings.'],
        correctAnswer: 'Implementing callback mechanisms.',
        explanation: 'Function pointers allow you to pass one function as an argument to another. The receiving function can then "call back" the function that was passed to it, which is a powerful and flexible technique.',
      },
      {
        id: 44,
        text: 'What does `p[i]` mean if `p` is a pointer?',
        type: 'mcq',
        options: ['It is a syntax error.', 'It means `*(p+i)`.', 'It means `*p + i`.', 'It means `p+i`.'],
        correctAnswer: 'It means `*(p+i)`.',
        explanation: 'The array subscript notation `a[i]` is defined as being exactly equivalent to `*(a+i)`. This works for both array names and pointer variables.',
      },
      {
        id: 45,
        text: 'Can you use the `sizeof` operator on a `void *` pointer?',
        type: 'mcq',
        options: ['No, it will cause a compile error.', 'Yes, it gives the size of the pointer itself.', 'Yes, it gives the size of the data it points to.', 'Only after casting.'],
        correctAnswer: 'Yes, it gives the size of the pointer itself.',
        explanation: '`sizeof` can be used on any pointer type. It will return the size of the pointer variable (the memory address), not the size of the data it points to.',
      },
      {
        id: 46,
        text: 'What will be printed?',
        type: 'code',
        codeSnippet: '#include <stdio.h>\n\nint main() {\n    char *str = "World";\n    str++;\n    printf("%s", str);\n    return 0;\n}',
        correctAnswer: 'orld',
        explanation: 'The pointer `str` is initially pointing to \'W\'. `str++` increments the pointer to point to the next character, \'o\'. `printf("%s", str)` then prints the string starting from that new position.',
      },
      {
        id: 47,
        text: 'What is the main difference between `malloc` and `calloc`?',
        type: 'mcq',
        options: ['`malloc` is for single elements, `calloc` is for arrays.', '`calloc` initializes the allocated memory to zero, `malloc` does not.', '`malloc` returns `void *`, `calloc` returns `int *`.', '`calloc` is faster than `malloc`.'],
        correctAnswer: '`calloc` initializes the allocated memory to zero, `malloc` does not.',
        explanation: '`malloc` allocates a block of memory and leaves it uninitialized (containing garbage values). `calloc` allocates memory and sets all its bits to zero.',
      },
      {
        id: 48,
        text: 'What will be the output of `printf("%p", NULL);` on most systems?',
        type: 'mcq',
        options: ['0', '0x0', '(nil)', 'An error'],
        correctAnswer: '(nil)',
        explanation: 'The `%p` format specifier is for printing pointers. While the underlying value of `NULL` is often 0, `printf` typically displays it as `(nil)` for clarity.',
      },
      {
        id: 49,
        text: 'Can a `void` pointer be dereferenced?',
        type: 'mcq',
        options: ['Yes, directly.', 'No, it must be cast to another pointer type first.', 'Only if it points to an `int`.', 'Yes, but it returns a `void` value.'],
        correctAnswer: 'No, it must be cast to another pointer type first.',
        explanation: 'The compiler needs to know the size and type of the data being pointed to in order to dereference a pointer. A `void` pointer holds no such type information, so it must be cast before dereferencing.',
      },
      {
        id: 50,
        text: 'Which is a correct way to allocate memory for a string of 50 characters?',
        type: 'mcq',
        options: ['`char *s = malloc(50);`', '`char *s = malloc(51);`', '`char *s = malloc(49);`', '`char s[50];`'],
        correctAnswer: '`char *s = malloc(51);`',
        explanation: 'To store a string of 50 characters, you need 50 bytes for the characters and 1 extra byte for the null terminator (`\\0`). Therefore, 51 bytes must be allocated.',
      },
    ],
  },
  {
    id: 'c-advanced-1',
    title: 'Advanced C Topics',
    description: 'Challenge yourself with advanced C programming questions.',
    difficulty: 'Hard',
    questions: [
      {
        id: 1,
        text: 'What is the purpose of the `volatile` keyword?',
        type: 'mcq',
        options: [
          'To prevent the compiler from optimizing access to a variable.',
          'To declare a variable that cannot be modified.',
          'To create a variable that is visible to all functions.',
          'To allocate memory from the heap.',
        ],
        correctAnswer: 'To prevent the compiler from optimizing access to a variable.',
        explanation: 'The `volatile` keyword tells the compiler that a variable\'s value may change at any time without any action being taken by the code the compiler finds nearby. This is crucial for variables modified by hardware or in interrupt service routines.',
      },
      {
        id: 2,
        text: 'What does the `realloc` function do if it fails to allocate memory?',
        type: 'code',
        codeSnippet: '#include <stdlib.h>\n\n// What does realloc return on failure?',
        correctAnswer: 'NULL',
        explanation: 'If `realloc` fails to resize the memory block, it returns a NULL pointer, and crucially, the original memory block is left unchanged and is not freed.',
      },
      {
        id: 3,
        text: 'What does the `restrict` keyword, introduced in C99, signify?',
        type: 'mcq',
        options: ['The pointer is the only way to access the object it points to within its scope.', 'The pointer cannot be NULL.', 'The memory the pointer points to cannot be modified.', 'The pointer can only be used in a single thread.'],
        correctAnswer: 'The pointer is the only way to access the object it points to within its scope.',
        explanation: '`restrict` is a hint to the compiler that for the lifetime of the pointer, only the pointer itself or a value directly derived from it will be used to access the object. This allows for more aggressive optimizations by removing concerns about aliasing.',
      },
      {
        id: 4,
        text: 'What is a bit-field in a C struct?',
        type: 'mcq',
        options: ['A special type of pointer.', 'A member of a struct that allows packing of data into less than a full byte.', 'A flag used for debugging.', 'An array of bits.'],
        correctAnswer: 'A member of a struct that allows packing of data into less than a full byte.',
        explanation: 'Bit-fields allow you to specify the number of bits a member should occupy (e.g., `unsigned int is_keyword : 1;`). This is useful for memory-sensitive applications or interfacing with hardware registers.',
      },
      {
        id: 5,
        text: 'What is the token-pasting operator in the C preprocessor?',
        type: 'mcq',
        options: ['`#`', '`##`', '`@`', '`$$`'],
        correctAnswer: '`##`',
        explanation: 'The `##` operator concatenates two tokens in a macro expansion. For example, `#define PASTE(a, b) a##b` would make `PASTE(name, 1)` expand to `name1`.',
      },
      {
        id: 6,
        text: 'What is the stringizing operator in the C preprocessor?',
        type: 'mcq',
        options: ['`#`', '`##`', '`&`', '`\'\'`'],
        correctAnswer: '`#`',
        explanation: 'When used in a macro definition, the `#` operator turns the following macro argument into a string literal. For example, `#define STRINGIZE(x) #x` would make `STRINGIZE(hello)` expand to `"hello"`.',
      },
      {
        id: 7,
        text: 'What is a flexible array member in a C struct?',
        type: 'mcq',
        options: ['An array that can change its data type.', 'A pointer to an array.', 'The last member of a struct, declared as an array with no size, used for variable-length data.', 'An array stored on the heap.'],
        correctAnswer: 'The last member of a struct, declared as an array with no size, used for variable-length data.',
        explanation: 'Declared like `char data[];` as the last member, it allows allocating a struct with extra space at the end for a variable-sized array, all in a single block of memory.',
      },
      {
        id: 8,
        text: 'What is the purpose of a `union` in C?',
        type: 'mcq',
        options: ['To store multiple variables in the same memory location.', 'To combine two structs.', 'To create a new data type.', 'To define a set of constants.'],
        correctAnswer: 'To store multiple variables in the same memory location.',
        explanation: 'All members of a union share the same memory space. The size of the union is the size of its largest member. It is used to interpret the same memory block as different data types at different times.',
      },
      {
        id: 9,
        text: 'How do you create a variadic function (one that accepts a variable number of arguments)?',
        type: 'mcq',
        options: ['Using the `variadic` keyword.', 'Using an array of pointers.', 'Using the `<stdarg.h>` header and its macros (`va_list`, `va_start`, `va_arg`, `va_end`).', 'It is not possible in C.'],
        correctAnswer: 'Using the `<stdarg.h>` header and its macros (`va_list`, `va_start`, `va_arg`, `va_end`).',
        explanation: 'The `<stdarg.h>` library provides a standard way to access arguments in a function that takes a variable number of them, like `printf`.',
      },
      {
        id: 10,
        text: 'What does the `static` keyword do when applied to a global variable or a function?',
        type: 'mcq',
        options: ['It makes the variable or function constant.', 'It causes the variable to retain its value between calls.', 'It limits the visibility of the variable or function to the current source file.', 'It allocates the variable on the heap.'],
        correctAnswer: 'It limits the visibility of the variable or function to the current source file.',
        explanation: 'Applying `static` at the file scope gives the identifier internal linkage, meaning it cannot be accessed from other source files using `extern`.',
      },
      {
        id: 11,
        text: 'What is the output of this bitwise operation: `5 & 3`?',
        type: 'mcq',
        options: ['1', '2', '3', '7'],
        correctAnswer: '1',
        explanation: 'In binary, 5 is `0101` and 3 is `0011`. The bitwise AND operation `&` results in `0001`, which is 1 in decimal.',
      },
      {
        id: 12,
        text: 'What is the output of this bitwise operation: `5 | 3`?',
        type: 'mcq',
        options: ['1', '5', '7', '8'],
        correctAnswer: '7',
        explanation: 'In binary, 5 is `0101` and 3 is `0011`. The bitwise OR operation `|` results in `0111`, which is 7 in decimal.',
      },
      {
        id: 13,
        text: 'What is the output of this bitwise operation: `5 ^ 3`?',
        type: 'mcq',
        options: ['2', '5', '6', '7'],
        correctAnswer: '6',
        explanation: 'In binary, 5 is `0101` and 3 is `0011`. The bitwise XOR operation `^` results in `0110`, which is 6 in decimal.',
      },
      {
        id: 14,
        text: 'What does the `#pragma` directive do?',
        type: 'mcq',
        options: ['It defines a macro.', 'It includes a header file.', 'It provides implementation-specific instructions to the compiler.', 'It marks the end of a code block.'],
        correctAnswer: 'It provides implementation-specific instructions to the compiler.',
        explanation: '`#pragma` is used for non-standard, compiler-specific features, such as controlling optimizations or suppressing warnings. A common example is `#pragma once` as an include guard.',
      },
      {
        id: 15,
        text: 'What is the purpose of `setjmp` and `longjmp`?',
        type: 'mcq',
        options: ['To jump to a specific line number.', 'To implement a non-local goto, saving a calling environment and jumping back to it.', 'To manage threads.', 'To allocate and deallocate memory.'],
        correctAnswer: 'To implement a non-local goto, saving a calling environment and jumping back to it.',
        explanation: '`setjmp` saves the current execution context (like the stack pointer) in a `jmp_buf` variable. `longjmp` can then be called from a deeply nested function to immediately return to the point where `setjmp` was called. It\'s often used for error handling.',
      },
      {
        id: 16,
        text: 'Which file opening mode in `fopen` is used for reading and writing to a binary file?',
        type: 'mcq',
        options: ['`"rw"`', '`"r+"`', '`"wb+"`', '`"b+"`'],
        correctAnswer: '`"wb+"`',
        explanation: '`"w"` means write (truncate or create), `b` means binary mode, and `+` means update (reading and writing). `"wb+"` opens a binary file for both reading and writing, creating it if it doesn\'t exist or truncating it if it does.',
      },
      {
        id: 17,
        text: 'What is tail-call optimization?',
        type: 'mcq',
        options: ['An optimization for string tails.', 'A compiler optimization where a recursive call at the very end of a function is replaced by a goto, saving stack space.', 'An optimization for linked list traversal.', 'A way to optimize file I/O.'],
        correctAnswer: 'A compiler optimization where a recursive call at the very end of a function is replaced by a goto, saving stack space.',
        explanation: 'If the last action of a function is to call itself, the compiler can reuse the current stack frame instead of creating a new one. This turns deep recursion into an efficient loop.',
      },
      {
        id: 18,
        text: 'What is the difference between a macro and a function?',
        type: 'mcq',
        options: ['Macros are always faster.', 'Functions have type checking, while macros do not.', 'Macros are expanded by the compiler, functions by the preprocessor.', 'There is no significant difference.'],
        correctAnswer: 'Functions have type checking, while macros do not.',
        explanation: 'Macros are simple text substitutions done by the preprocessor before compilation. This means arguments are not type-checked, which can lead to unexpected behavior and errors. Functions, however, have proper type checking for arguments.',
      },
      {
        id: 19,
        text: 'What does the `_Generic` keyword (from C11) do?',
        type: 'mcq',
        options: ['Creates a generic pointer.', 'Defines a generic struct.', 'Selects an expression at compile time based on the type of its controlling expression.', 'Starts a generic function definition.'],
        correctAnswer: 'Selects an expression at compile time based on the type of its controlling expression.',
        explanation: '`_Generic` allows you to write macros that behave differently based on the data type of their arguments, enabling a form of compile-time polymorphism.',
      },
      {
        id: 20,
        text: 'What is an X-Macro?',
        type: 'mcq',
        options: ['A special type of debug macro.', 'A technique using a list defined in one macro, which is then expanded multiple times by another macro with different definitions.', 'A macro that expands to an XML-like syntax.', 'An outdated macro feature.'],
        correctAnswer: 'A technique using a list defined in one macro, which is then expanded multiple times by another macro with different definitions.',
        explanation: 'X-Macros are a preprocessor trick to avoid repeating lists of items. You define a list of items using a macro, then `#include` that file or `#define` another macro multiple times to generate code (e.g., enum members, string names, function definitions) from that list.',
      },
      {
        id: 21,
        text: 'What is the purpose of the `ftell` function?',
        type: 'mcq',
        options: ['To tell a story from a file.', 'To return the current file position indicator for the stream.', 'To move the file position indicator to a specific location.', 'To check if a file exists.'],
        correctAnswer: 'To return the current file position indicator for the stream.',
        explanation: '`ftell` returns the current value of the file position indicator, which represents the number of bytes from the beginning of the file.',
      },
      {
        id: 22,
        text: 'What is "object-like macro" vs. "function-like macro"?',
        type: 'mcq',
        options: ['One is for structs, the other for functions.', 'An object-like macro is a simple substitution (`#define PI 3.14`), while a function-like macro takes arguments (`#define MAX(a,b) ...`).', 'Object-like macros are for pointers.', 'Function-like macros can only be used inside functions.'],
        correctAnswer: 'An object-like macro is a simple substitution (`#define PI 3.14`), while a function-like macro takes arguments (`#define MAX(a,b) ...`).',
        explanation: 'The preprocessor distinguishes between these two based on whether there is a parenthesis `(` immediately after the macro name in the `#define` directive.',
      },
      {
        id: 23,
        text: 'What is a "compound literal" (from C99)?',
        type: 'mcq',
        options: ['A string literal that contains multiple lines.', 'An unnamed object created on the fly with a given type and initializer list.', 'A complex number.', 'A literal value that is also a pointer.'],
        correctAnswer: 'An unnamed object created on the fly with a given type and initializer list.',
        explanation: 'For example, `(int[]){1, 2, 3}` creates an unnamed array of three integers. This is very useful for passing arrays or structs to functions without needing to declare a named variable first.',
      },
      {
        id: 24,
        text: 'What is `__func__` (from C99)?',
        type: 'mcq',
        options: ['A macro that returns the current file name.', 'A predefined identifier that holds the name of the current function as a string.', 'A keyword to declare a function.', 'A pointer to the current function.'],
        correctAnswer: 'A predefined identifier that holds the name of the current function as a string.',
        explanation: '`__func__` is implicitly declared in every function as `static const char __func__[] = "function-name";`. It is very useful for logging and debugging.',
      },
      {
        id: 25,
        text: 'What is the purpose of a signal handler in C?',
        type: 'mcq',
        options: ['To process network signals.', 'A function that is executed in response to a specific signal (like an interrupt or error) received by the process.', 'To debug traffic lights.', 'To link two object files.'],
        correctAnswer: 'A function that is executed in response to a specific signal (like an interrupt or error) received by the process.',
        explanation: 'Using the `signal()` function, you can register a custom function to be called when events like `SIGINT` (interrupt from Ctrl+C) or `SIGSEGV` (segmentation fault) occur.',
      },
      {
        id: 26,
        text: 'What is a common problem with function-like macros?',
        type: 'mcq',
        options: ['They are too slow.', 'They can cause unexpected behavior due to operator precedence and multiple evaluation of arguments.', 'They cannot return values.', 'They are not portable.'],
        correctAnswer: 'They can cause unexpected behavior due to operator precedence and multiple evaluation of arguments.',
        explanation: 'For example, in `#define SQUARE(x) x*x`, `SQUARE(a+b)` expands to `a+b*a+b`, which is wrong. Also, `SQUARE(i++)` expands to `i++*i++`, causing `i` to be incremented twice. Careful use of parentheses and avoiding arguments with side effects is crucial.',
      },
      {
        id: 27,
        text: 'In file I/O, what is the difference between buffered and unbuffered I/O?',
        type: 'mcq',
        options: ['Buffered I/O is faster.', 'Unbuffered I/O is faster.', 'Buffered I/O reads/writes data in chunks (a buffer) to reduce system calls, while unbuffered I/O performs a system call for every read/write.', 'Buffered I/O is for text files, unbuffered for binary.'],
        correctAnswer: 'Buffered I/O reads/writes data in chunks (a buffer) to reduce system calls, while unbuffered I/O performs a system call for every read/write.',
        explanation: 'Standard I/O functions like `printf` and `fscanf` are buffered. Unbuffered I/O is done with lower-level system calls like `read` and `write` (in POSIX systems).',
      },
      {
        id: 28,
        text: 'What is the purpose of the `#error` preprocessor directive?',
        type: 'mcq',
        options: ['To print an error message at runtime.', 'To cause the preprocessor to issue an error message and stop compilation.', 'To define a standard error code.', 'To handle exceptions.'],
        correctAnswer: 'To cause the preprocessor to issue an error message and stop compilation.',
        explanation: 'It is typically used inside conditional compilation blocks (`#if`, `#ifdef`) to prevent compilation if certain conditions are not met, e.g., `#ifndef SOME_MACRO\n#error "SOME_MACRO must be defined!"\n#endif`.',
      },
      {
        id: 29,
        text: 'What does "endianness" refer to?',
        type: 'mcq',
        options: ['The alignment of structs.', 'The order in which a sequence of bytes is stored in computer memory.', 'The character encoding standard.', 'The calling convention of a function.'],
        correctAnswer: 'The order in which a sequence of bytes is stored in computer memory.',
        explanation: 'Big-endian stores the most significant byte first (at the lowest address), while little-endian stores the least significant byte first. This is important for networking and file formats.',
      },
      {
        id: 30,
        text: 'What is an "inline function" (from C99)?',
        type: 'mcq',
        options: ['A function written on a single line.', 'A function that is automatically called.', 'A hint to the compiler to replace a function call with the function\'s body to reduce call overhead.', 'A function that can only be called once.'],
        correctAnswer: 'A hint to the compiler to replace a function call with the function\'s body to reduce call overhead.',
        explanation: 'Marking a function `inline` suggests that the compiler insert the function\'s code directly at the call site. This is best for very small, frequently called functions.',
      },
      {
        id: 31,
        text: 'What is a "tentative definition" in C?',
        type: 'mcq',
        options: ['A function prototype.', 'A declaration of a global variable without an initializer, like `int x;`.', 'A pointer that might be NULL.', 'A struct definition without any members.'],
        correctAnswer: 'A declaration of a global variable without an initializer, like `int x;`.',
        explanation: 'A file-scope declaration without an initializer and without `extern` is a tentative definition. If no other definition for the variable is found in the translation unit, it is implicitly initialized to zero.',
      },
      {
        id: 32,
        text: 'What is the difference between `const char *p` and `char * const p`?',
        type: 'mcq',
        options: ['No difference.', 'First is a pointer to a constant char, second is a constant pointer to a char.', 'First is a constant pointer to a char, second is a pointer to a constant char.', 'Both are syntax errors.'],
        correctAnswer: 'First is a pointer to a constant char, second is a constant pointer to a char.',
        explanation: 'Reading from right to left helps: `const char *p` is a pointer to a char that is constant (cannot change `*p`). `char * const p` is a constant pointer to a char that is not constant (cannot change `p`, but can change `*p`).',
      },
      {
        id: 33,
        text: 'What is "undefined behavior" (UB)?',
        type: 'mcq',
        options: ['Behavior that is defined by the user.', 'Behavior that results in a compiler error.', 'Behavior upon use of a non-portable or erroneous program construct for which the C standard imposes no requirements.', 'Behavior that is consistent across all compilers.'],
        correctAnswer: 'Behavior upon use of a non-portable or erroneous program construct for which the C standard imposes no requirements.',
        explanation: 'Actions like dereferencing a NULL pointer, signed integer overflow, or modifying a string literal result in UB. The program may crash, produce incorrect results, or appear to work fine, but it is not reliable.',
      },
      {
        id: 34,
        text: 'What is the purpose of the `aligned_alloc` function (from C11)?',
        type: 'mcq',
        options: ['To allocate memory that is aligned to a specific byte boundary.', 'To align text in the console output.', 'To reallocate memory to a new alignment.', 'To check if a pointer is aligned.'],
        correctAnswer: 'To allocate memory that is aligned to a specific byte boundary.',
        explanation: 'Certain operations, especially SIMD instructions, require data to be aligned in memory on specific boundaries (e.g., 16 or 32 bytes). `aligned_alloc` provides a standard way to request such memory.',
      },
      {
        id: 35,
        text: 'What does the `_Noreturn` function specifier (from C11) indicate?',
        type: 'mcq',
        options: ['The function returns no value (like `void`).', 'The function is not allowed to return to its caller.', 'The function never completes.', 'The function cannot be called recursively.'],
        correctAnswer: 'The function is not allowed to return to its caller.',
        explanation: 'This is a hint to the compiler and the programmer that the function will not return. Functions like `exit()` or `longjmp()` are examples. It allows for better optimization and error checking.',
      },
    ],
  },
];

export const getQuizById = (id: string): Quiz | undefined => {
  return quizzes.find((quiz) => quiz.id === id);
};
